Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercise
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercises
Operating systems are an essential part of any computer system. Similarly,
a course on operating systems is an essential part of any computer science
education. This field is undergoing rapid change, as computers are now
prevalent in virtually every arena of day-to-day life —from embedded devices
in automobiles through the most sophisticated planning tools for governments
and multinational firms. Yet the fundamental concepts remain fairly clear, and
it is on these that we base this book.
We wrote this book as a text for an introductory course in operating systems
at the junior or senior undergraduate level or at the first-year graduate level. We
hope that practitioners will also find it useful. It provides a clear description of
the concepts that underlie operating systems. As prerequisites, we assume that
the reader is familiar with basic data structures, computer organization, and
a high-level language, such as C or Java. The hardware topics required for an
understanding of operating systems are covered in Chapter 1. In that chapter,
we also include an overview of the fundamental data structures that are
prevalent in most operating systems. For code examples, we use predominantly
C, with some Java, but the reader can still understand the algorithms without
a thorough knowledge of these languages.
Concepts are presented using intuitive descriptions. Important theoretical
results are covered, but formal proofs are largely omitted. The bibliographical
notes at the end of each chapter contain pointers to research papers in which
results were first presented and proved, as well as references to recent material
for further reading. In place of proofs, figures and examples are used to suggest
why we should expect the result in question to be true.
The fundamental concepts and algorithms covered in the book are often
based on those used in both commercial and open-source operating systems.
Our aim is to present these concepts and algorithms in a general setting that
is not tied to one particular operating system. However, we present a large
number of examples that pertain to the most popular and the most innovative
operating systems, including Linux, Microsoft Windows, Apple Mac OS X , and
Solaris. We also include examples of both Android and i OS , currently the two
dominant mobile operating systems.
The organization of the text reflects our many years of teaching courses on
operating systems, as well as curriculum guidelines published by the IEEE
viiviii
Preface
Computing Society and the Association for Computing Machinery ( ACM ).
Consideration was also given to the feedback provided by the reviewers of
the text, along with the many comments and suggestions we received from
readers of our previous editions and from our current and former students.
Content of This Book
The text is organized in eight major parts:
• Overview. Chapters 1 and 2 explain what operating systems are, what
they do, and how they are designed and constructed. These chapters
discuss what the common features of an operating system are and what an
operating system does for the user. We include coverage of both traditional
PC and server operating systems, as well as operating systems for mobile
devices. The presentation is motivational and explanatory in nature. We
have avoided a discussion of how things are done internally in these
chapters. Therefore, they are suitable for individual readers or for students
in lower-level classes who want to learn what an operating system is
without getting into the details of the internal algorithms.
• Process management. Chapters 3 through 7 describe the process concept
and concurrency as the heart of modern operating systems. A process
is the unit of work in a system. Such a system consists of a collection
of concurrently executing processes, some of which are operating-system
processes (those that execute system code) and the rest of which are user
processes (those that execute user code). These chapters cover methods for
process scheduling, interprocess communication, process synchronization,
and deadlock handling. Also included is a discussion of threads, as well
as an examination of issues related to multicore systems and parallel
programming.
• Memory management. Chapters 8 and 9 deal with the management of
main memory during the execution of a process. To improve both the
utilization of the CPU and the speed of its response to its users, the
computer must keep several processes in memory. There are many different
memory-management schemes, reflecting various approaches to memory
management, and the effectiveness of a particular algorithm depends on
the situation.
• Storage management. Chapters 10 through 13 describe how mass storage,
the file system, and I/O are handled in a modern computer system. The
file system provides the mechanism for on-line storage of and access
to both data and programs. We describe the classic internal algorithms
and structures of storage management and provide a firm practical
understanding of the algorithms used —their properties, advantages, and
disadvantages. Since the I/O devices that attach to a computer vary widely,
the operating system needs to provide a wide range of functionality to
applications to allow them to control all aspects of these devices. We
discuss system I/O in depth, including I/O system design, interfaces, and
internal system structures and functions. In many ways, I/O devices are
the slowest major components of the computer. Because they represent aPreface
ix
performance bottleneck, we also examine performance issues associated
with I/O devices.
• Protection and security. Chapters 14 and 15 discuss the mechanisms
necessary for the protection and security of computer systems. The
processes in an operating system must be protected from one another’s
activities, and to provide such protection, we must ensure that only
processes that have gained proper authorization from the operating system
can operate on the files, memory, CPU , and other resources of the system.
Protection is a mechanism for controlling the access of programs, processes,
or users to computer-system resources. This mechanism must provide a
means of specifying the controls to be imposed, as well as a means of
enforcement. Security protects the integrity of the information stored in
the system (both data and code), as well as the physical resources of the
system, from unauthorized access, malicious destruction or alteration, and
accidental introduction of inconsistency.
• Advanced topics. Chapters 16 and 17 discuss virtual machines and
distributed systems. Chapter 16 is a new chapter that provides an overview
of virtual machines and their relationship to contemporary operating
systems. Included is an overview of the hardware and software techniques
that make virtualization possible. Chapter 17 condenses and updates the
three chapters on distributed computing from the previous edition. This
change is meant to make it easier for instructors to cover the material in
the limited time available during a semester and for students to gain an
understanding of the core ideas of distributed computing more quickly.
• Case studies. Chapters 18 and 19 in the text, along with Appendices A and
B (which are available on ( http://www.os-book.com ), present detailed
case studies of real operating systems, including Linux, Windows 7,
F ree BSD , and Mach. Coverage of both Linux and Windows 7 are presented
throughout this text; however, the case studies provide much more detail.
It is especially interesting to compare and contrast the design of these two
very different systems. Chapter 20 briefly describes a few other influential
operating systems.
The Ninth Edition
As we wrote this Ninth Edition of Operating System Concepts, we were guided
by the recent growth in three fundamental areas that affect operating systems:
1. Multicore systems
2. Mobile computing
3. Virtualization
To emphasize these topics, we have integrated relevant coverage throughout
this new edition—and, in the case of virtualization, have written an entirely
new chapter. Additionally, we have rewritten material in almost every chapter
by bringing older material up to date and removing material that is no longer
interesting or relevant.x
Preface
We have also made substantial organizational changes. For example, we
have eliminated the chapter on real-time systems and instead have integrated
appropriate coverage of these systems throughout the text. We have reordered
the chapters on storage management and have moved up the presentation
of process synchronization so that it appears before process scheduling. Most
of these organizational changes are based on our experiences while teaching
courses on operating systems.
Below, we provide a brief outline of the major changes to the various
chapters:
• Chapter 1, Introduction, includes updated coverage of multiprocessor
and multicore systems, as well as a new section on kernel data structures.
Additionally, the coverage of computing environments now includes
mobile systems and cloud computing. We also have incorporated an
overview of real-time systems.
• Chapter 2, Operating-System Structures, provides new coverage of user
interfaces for mobile devices, including discussions of i OS and Android,
and expanded coverage of Mac OS X as a type of hybrid system.
• Chapter 3, Processes, now includes coverage of multitasking in mobile
operating systems, support for the multiprocess model in Google’s Chrome
web browser, and zombie and orphan processes in UNIX .
• Chapter 4, Threads, supplies expanded coverage of parallelism and
Amdahl’s law. It also provides a new section on implicit threading,
including Open MP and Apple’s Grand Central Dispatch.
• Chapter 5, Process Synchronization (previously Chapter 6), adds a new
section on mutex locks as well as coverage of synchronization using
Open MP , as well as functional languages.
• Chapter 6, CPU Scheduling (previously Chapter 5), contains new coverage
of the Linux CFS scheduler and Windows user-mode scheduling. Coverage
of real-time scheduling algorithms has also been integrated into this
chapter.
• Chapter 7, Deadlocks, has no major changes.
• Chapter 8, Main Memory, includes new coverage of swapping on mobile
systems and Intel 32- and 64-bit architectures. A new section discusses
ARM architecture.
• Chapter 9, Virtual Memory, updates kernel memory management to
include the Linux SLUB and SLOB memory allocators.
• Chapter 10, Mass-Storage Structure (previously Chapter 12), adds cover-
age of solid-state disks.
• Chapter 11, File-System Interface (previously Chapter 10), is updated
with information about current technologies.
• Chapter 12, File-System Implementation (previously Chapter 11), is
updated with coverage of current technologies.
• Chapter 13, I/O, updates technologies and performance numbers, expands
coverage of synchronous/asynchronous and blocking/nonblocking I/O ,
and adds a section on vectored I/O .Preface
xi
• Chapter 14, Protection, has no major changes.
• Chapter 15, Security, has a revised cryptography section with modern
notation and an improved explanation of various encryption methods and
their uses. The chapter also includes new coverage of Windows 7 security.
• Chapter 16, Virtual Machines, is a new chapter that provides an overview
of virtualization and how it relates to contemporary operating systems.
• Chapter 17, Distributed Systems, is a new chapter that combines and
updates a selection of materials from previous Chapters 16, 17, and 18.
• Chapter 18, The Linux System (previously Chapter 21), has been updated
to cover the Linux 3.2 kernel.
• Chapter 19, Windows 7, is a new chapter presenting a case study of
Windows 7.
• Chapter 20, Influential Operating Systems (previously Chapter 23), has
no major changes.
Programming Environments
This book uses examples of many real-world operating systems to illustrate
fundamental operating-system concepts. Particular attention is paid to Linux
and Microsoft Windows, but we also refer to various versions of UNIX
(including Solaris, BSD , and Mac OS X ).
The text also provides several example programs written in C and
Java. These programs are intended to run in the following programming
environments:
•
POSIX . POSIX (which stands for Portable Operating System Interface) repre-
sents a set of standards implemented primarily for UNIX -based operating
systems. Although Windows systems can also run certain POSIX programs,
our coverage of POSIX focuses on UNIX and Linux systems. POSIX -compliant
systems must implement the POSIX core standard ( POSIX .1); Linux, Solaris,
and Mac OS X are examples of POSIX -compliant systems. POSIX also
defines several extensions to the standards, including real-time extensions
( POSIX 1.b) and an extension for a threads library ( POSIX 1.c, better known
as Pthreads). We provide several programming examples written in C
illustrating the POSIX base API , as well as Pthreads and the extensions for
real-time programming. These example programs were tested on Linux 2.6
and 3.2 systems, Mac OS X 10.7, and Solaris 10 using the gcc 4.0 compiler.
• Java. Java is a widely used programming language with a rich
API and
built-in language support for thread creation and management. Java
programs run on any operating system supporting a Java virtual machine
(or JVM ). We illustrate various operating-system and networking concepts
with Java programs tested using the Java 1.6 JVM .
• Windows systems. The primary programming environment for Windows
systems is the Windows API , which provides a comprehensive set of func-
tions for managing processes, threads, memory, and peripheral devices.
We supply several C programs illustrating the use of this API . Programs
were tested on systems running Windows XP and Windows 7.xii
Preface
We have chosen these three programming environments because we
believe that they best represent the two most popular operating-system models
—Windows and UNIX /Linux—along with the widely used Java environment.
Most programming examples are written in C, and we expect readers to be
comfortable with this language. Readers familiar with both the C and Java
languages should easily understand most programs provided in this text.
In some instances—such as thread creation—we illustrate a specific
concept using all three programming environments, allowing the reader
to contrast the three different libraries as they address the same task. In
other situations, we may use just one of the API s to demonstrate a concept.
For example, we illustrate shared memory using just the POSIX API ; socket
programming in TCP/IP is highlighted using the Java API .
Linux Virtual Machine
To help students gain a better understanding of the Linux system, we
provide a Linux virtual machine, including the Linux source code,
that is available for download from the the website supporting this
text ( http://www.os-book.com ). This virtual machine also includes a
gcc development environment with compilers and editors. Most of the
programming assignments in the book can be completed on this virtual
machine, with the exception of assignments that require Java or the Windows
API .
We also provide three programming assignments that modify the Linux
kernel through kernel modules:
1. Adding a basic kernel module to the Linux kernel.
2. Adding a kernel module that uses various kernel data structures.
3. Adding a kernel module that iterates over tasks in a running Linux
system.
Over time it is our intention to add additional kernel module assignments on
the supporting website.
Supporting Website
When you visit the website supporting this text at http://www.os-book.com ,
you can download the following resources:
•
•
•
•
•
•
Linux virtual machine
C and Java source code
Sample syllabi
Set of Powerpoint slides
Set of figures and illustrations
F ree BSD and Mach case studiesPreface
xiii
• Solutions to practice exercisess